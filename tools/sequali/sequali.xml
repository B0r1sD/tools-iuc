<tool id="sequali" name="sequali" version="@TOOL_VERSION@+galaxy@VERSION_SUFFIX@" profile="21.05">
    <description>Fast sequencing data quality metrics for short and long reads</description>
    <macros>
        <token name="@TOOL_VERSION@">0.12.0</token>
        <token name="@VERSION_SUFFIX@">0</token>        
    </macros>
    <xrefs>
        <xref type="bio.tools">sequali</xref>
    </xrefs>
    <requirements>
        <requirement type="package" version="@TOOL_VERSION@">sequali</requirement>
    </requirements>
    <version_command><![CDATA[
        sequali --version
        ]]>
    </version_command>
    <command detect_errors="exit_code"><![CDATA[
    #set $input_1 = str($input_reads.element_identifier)
    ln -s '${input_reads}' '$input_1' &&

    #if $input_reads_rev:
        #set $input_2 = str($input_reads_rev.element_identifier)
        ln -s '${input_reads_rev}' '$input_2' &&
    #else:
        #set $input_2 = ''
    #end if

    mkdir -p '${html_report.files_path}' &&
    sequali
        #if $adapter.dataset and str($adapter) > ''
            --adapter-file '${adapter}'
        #end if
        #if $overrepresentation_threshold and str($overrepresentation_threshold) > '':
            --overrepresentation-threshold-fraction '${overrepresentation_threshold}'
        #end if
        #if $overrep_min_threshold and str($overrep_min_threshold) > '':
            --overrepresentation-min-threshold '${overrep_min_threshold}'
        #end if
        #if $overrep_max_threshold and str($overrep_max_threshold) > '':
            --overrepresentation-max-threshold '${overrep_max_threshold}'
        #end if
        #if $overrep_max_unique_fragments and str($overrep_max_unique_fragments) > '':
            --overrepresentation-max-unique-fragments '${overrep_max_unique_fragments}'
        #end if
        #if $overrep_fragment_length and str($overrep_fragment_length) > '':
            --overrepresentation-fragment-length '${overrep_fragment_length}'
        #end if
        #if $overrep_sample_every and str($overrep_sample_every) > '':
            --overrepresentation-sample-every '${overrep_sample_every}'
        #end if
        #if $dup_max_stored_fingerprints and str($dup_max_stored_fingerprints) > '':
            --duplication-max-stored-fingerprints '${dup_max_stored_fingerprints}'
        #end if
        #if $fp_front_length and str($fp_front_length) > '':
            --fingerprint-front-length '${fp_front_length}'
        #end if
        #if $fp_back_length and str($fp_back_length) > '':
            --fingerprint-back-length '${fp_back_length}'
        #end if
        #if $fp_front_offset and str($fp_front_offset) > '':
            --fingerprint-front-offset '${fp_front_offset}'
        #end if
        #if $fp_back_offset and str($fp_back_offset) > '':
            --fingerprint-back-offset '${fp_back_offset}'
        #end if
        --html '${html_report.files_path}/output.html'
        --json '${html_report.files_path}/output.json'
        --threads \${GALAXY_SLOTS:-2}
        '${input_1}'
        #if $input_2:
            '${input_2}'
        #end if

    && cp '${html_report.files_path}/output.html' output.html
    && cp '${html_report.files_path}/output.json' output.json

    ]]></command>
    <inputs>
        <param name="input_reads" format="fastq,fastq.gz,bam" type="data" label="Raw read data (fastq or bam). Compression and file format are automatically detected." />
        <param name="input_reads_rev" format="fastq,fastq.gz" type="data" optional="true"
                label="Raw read data for Illumina paired-end reads (fastq)" />
        <section name="additional_inputs" title="Additional parameters" expanded="False">
            <param argument="--adapter-file" name="adapter" format="tabular" type="data" optional= "true" label="File with adapters to search for." 
                help="TSV file with header: Name, Sequencing Technology, Probe sequence, sequence position. Default: https://github.com/rhpvorderman/sequali/tree/develop/src/sequali/adapters/adapter_list.tsv"/>
            <param argument="--overrepresentation-threshold-fraction" name="overrepresentation_threshold" type="float" optional="true"
                    label="At what fraction a sequence is determined to be overrepresented." help="The threshold is calculated as fraction times the number of sampled sequences. Default: 0.001 (1 in 1,000)."/>
            <param argument="--overrepresentation-min-threshold" name="overrep_min_threshold" type="integer" optional="true"
                    label="The minimum amount of occurrences for a sequence to be considered overrepresented." 
                    help="The minimum amount of occurrences for a sequence to be considered overrepresented, regardless of the bound set by the threshold fraction. Useful for smaller files. Default: 100."/>
            <param argument="--overrepresentation-max-threshold" name="overrep_max_threshold" type="integer" optional="true"
                    label="The amount of occurrences for a sequence to be considered overrepresented." 
                    help="The amount of occurrences for a sequence to be considered overrepresented, regardless of the bound set by the threshold fraction. Useful for very large files. Default: unlimited."/>
            <param argument="--overrepresentation-max-unique-fragments" name="overrep_max_unique_fragments" type="integer" optional="true"
                    label="The maximum amount of unique fragments to store." 
                    help="Larger amounts increase the sensitivity of finding overrepresented sequences at the cost of increasing memory usage. Default: 5,000,000."/>
            <param argument="--overrepresentation-fragment-length" name="overrep_fragment_length" type="integer" optional="true" max="31"
                    label="The length of the fragments to sample." 
                    help="The maximum is 31. Default: 21."/>
            <param argument="--overrepresentation-sample-every" name="overrep_sample_every" type="integer" optional="true"
                    label="How often a read should be sampled." 
                    help=" More samples leads to better precision, lower speed, and also towards more bias towards the beginning of the file as the fragment store gets filled up with more sequences from the beginning. Default: 1 in 8."/>
            <param argument="--duplication-max-stored-fingerprints" name="dup_max_stored_fingerprints" type="integer" optional="true"
                    label="Determines how many fingerprints are maximally stored to estimate the duplication rate." 
                    help="More fingerprints leads to a more accurate estimate, but also more memory usage. Default: 1,000,000."/>
            <param argument="--fingerprint-front-length" name="fp_front_length" type="integer" optional="true"
                    label="Number of bases to be taken for the deduplication fingerprint from the front of the sequence." 
                    help="Default: 8."/>
            <param argument="--fingerprint-back-length" name="fp_back_length" type="integer" optional="true"
                    label="Number of bases to be taken for the deduplication fingerprint from the back of the sequence." 
                    help="Default: 8."/>
            <param argument="--fingerprint-front-offset" name="fp_front_offset" type="integer" optional="true"
                    label="Set the offset for the front part of the deduplication fingerprint." 
                    help="Useful for avoiding adapter sequences. Default: 64 for single end, 0 for paired sequences."/>
            <param argument="--fingerprint-back-offset" name="fp_back_offset" type="integer" optional="true"
                    label="Set the offset for the back part of the deduplication fingerprint." 
                    help="Useful for avoiding adapter sequences. Default: 64 for single end, 0 for paired sequences."/>
        </section>     
    </inputs>
    <outputs>
        <data format="html" name="html_report" from_work_dir="output.html" label="${tool.name} on ${on_string}: HTML report" />
        <data format="json" name="json_report" from_work_dir="output.json" label="${tool.name} on ${on_string}: JSON report" />
    </outputs>
    <tests>
        <test expect_num_outputs="2">
            <param name="input_reads" value="input_fwd.fastq" />
            <output name="html_report" ftype="html">
                <assert_contents>
                    <has_text text="Sequali report"/>
                </assert_contents>            
            </output>
            <output name="json_report" ftype="json">
                <assert_contents>
                    <has_text text="sequali_version"/>
                </assert_contents>
            </output>
        </test>
        <test expect_num_outputs="2">
            <param name="input_reads" value="input_fwd.fastq" />
            <param name="input_reads_rev" value="input_rev.fastq" />
            <output name="html_report" ftype="html">
                <assert_contents>
                    <has_text text="Sequali report"/>
                    <has_text text="Filename read 2"/>
                </assert_contents>            
            </output>
            <output name="json_report" ftype="json">
                <assert_contents>
                    <has_text text="sequali_version"/>
                    <has_text text="filename_read2"/>
                </assert_contents>
            </output>
        </test>
        <test expect_num_outputs="2">
            <param name="input_reads" value="input_nanopore.fastq" />
            <output name="html_report" ftype="html">
                <assert_contents>
                    <has_text text="Sequali report"/>
                </assert_contents>
            </output>
            <output name="json_report" ftype="json">
                <assert_contents>
                    <has_text text="sequali_version"/>
                </assert_contents>
            </output>
        </test>
        <test expect_failure="true">
            <param name="input_reads" value="input_fail.fastq" />          
        </test>
    </tests>
    <help><![CDATA[
.. class:: infomark

**Purpose**

Sequali_ is a tool for fast sequencing data quality metrics for short and long reads. 

Features:

- MultiQC support since MultiQC version 1.22.
- Low memory footprint, small install size and fast execution times.
- Sequali typically needs less than 2 GB of memory and 3-30 minutes runtime when run on 2 cores (the default).
- Informative graphs that allow for judging the quality of a sequence at a quick glance.
- Overrepresentation analysis using 21 bp sequence fragments. Overrepresented sequences are checked against the NCBI univec database.
- Estimate duplication rate using a fingerprint subsampling technique which is also used in filesystem duplication estimation.
- Checks for 6 illumina adapter sequences and 17 nanopore adapter sequences for single read data.
- Determines adapters by overlap analysis for paired read data.
- Insert size metrics for paired read data.
- Per tile quality plots for illumina reads.
- Channel and other plots for nanopore reads.

-----

**Supported formats**

- FASTQ. Only the Sanger variation with a phred offset of 33 and the error rate calculation of 10 ^ (-phred/10) is supported. All sequencers use this format today.
    - Paired end sequencing data is supported.
    - For sequences called by illumina base callers an additional plot with the per tile quality will be provided.
    - For sequences called by guppy additional plots for nanopore specific data will be provided.
- (unaligned) BAM with single reads. Read-pair information is currently ignored.
    - For BAM data as delivered by dorado additional nanopore plots will be provided.

-----

**Outputs**

Sequali produces informative HTML report with dynamic plots for each quality metric.

.. _Sequali: https://sequali.readthedocs.io/en/latest/
    ]]></help>
    <citations>
        <citation type="bibtex">
        @article{10.1093/bioadv/vbaf010,
            author = {Vorderman, Ruben H P},
            title = {Sequali: efficient and comprehensive quality control of short- and long-read sequencing data},
            journal = {Bioinformatics Advances},
            volume = {5},
            number = {1},
            pages = {vbaf010},
            year = {2025},
            month = {01},
            issn = {2635-0041},
            doi = {10.1093/bioadv/vbaf010},
            url = {https://doi.org/10.1093/bioadv/vbaf010},
            eprint = {https://academic.oup.com/bioinformaticsadvances/article-pdf/5/1/vbaf010/61683840/vbaf010.pdf},
        }
        </citation>
    </citations>
</tool>